[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Velkommen!",
    "section": "",
    "text": "Dette er nettsiden til læreboken R for alle: Innføring i programmering for kvalitative fag av Thomas Hegghammer (Fagbokforlaget). Her vil du finne informasjon om boken og en del ekstramateriell.\n\n\nFinn ut mer\nLes et utdrag\nBestill\n\n\n\nNyheter\n\nForventet publiseringsdato: juni 2024."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "bestill.html",
    "href": "bestill.html",
    "title": "Bestill boken",
    "section": "",
    "text": "Fra Fagbokforlaget.no\nFra Norli.no\nFra Akademika.no\nFra Bokkilden.no\nFra Ark.no\nFra Adlibris.com"
  },
  {
    "objectID": "innhold.html",
    "href": "innhold.html",
    "title": "Om boken",
    "section": "",
    "text": "R for alle er en innføringsbok i programmeringspråket R for humanister og samfunnsvitere. Den er for deg som vil lære å programmere litt, men som ikke har behov for å gå dypt inn i informatikkens eller statistikkens verden. Boken gir en lettfattelig innføring i R med fokus på håndfaste, nyttige verktøy som du umiddelbart kan ta i bruk i ditt arbeid. Du vil lære å lage diagrammer, tegne egne kart, skrape nettsider, trekke ut tekst fra bilder, bygge nettsider, samt å analysere tekst, bilder, lyd og video på spennende nye måter. Eksemplene er hentet fra vikinghistorie, islandsk geografi, skandinavisk kvinnekamp, norske partiprogrammer, nazistpropaganda fra 1941, 1880-tallskunst og tidlige norske komponister. Boken innfører gradvis mer avanserte teknikker på en pedagogisk måte og er akkompagnert av en R-pakke som gjør det lett å laste ned eksempelkode. Boken egner seg både for fullstendige nybegynnere og for deg som allerede har programmert en stund."
  },
  {
    "objectID": "om_boken.html",
    "href": "om_boken.html",
    "title": "Om boken",
    "section": "",
    "text": "R for alle er en innføringsbok i programmeringspråket R for humanister og samfunnsvitere. Den er for deg som vil lære å programmere litt, men som ikke har behov for å gå dypt inn i informatikkens eller statistikkens verden. Boken gir en lettfattelig innføring i R med fokus på håndfaste, nyttige verktøy som du umiddelbart kan ta i bruk i ditt arbeid. Du vil lære å lage diagrammer, tegne egne kart, skrape nettsider, trekke ut tekst fra bilder, bygge nettsider, samt å analysere tekst, bilder, lyd og video på spennende nye måter. Eksemplene er hentet fra vikinghistorie, islandsk geografi, skandinavisk kvinnekamp, norske partiprogrammer, nazistpropaganda fra 1941, 1880-tallskunst og tidlige norske komponister. Boken innfører gradvis mer avanserte teknikker på en pedagogisk måte og er akkompagnert av en R-pakke som gjør det lett å laste ned eksempelkode. Boken egner seg både for fullstendige nybegynnere og for deg som allerede har programmert en stund.\nThomas Hegghammer er professor i statsvitenskap ved Universitetet i Oxford, hvor han blant annet underviser i programmering for kvalitativ forskning. I tillegg til sin forskning på militant islamisme har han publisert artikler om optisk karaktergjenkjenning og laget R-pakken daiR.\n\n\n\n\n\n\n\nInnholdsfortegnelse\n\nInnledning\nKjenn din PC\nInstallér R\nForstå R-grammatikken\nTegn grafer\nFremstill diagrammer\nGenerér egne kart\nUtvid R-ferdighetene\nSamle data\nTrekk ut innhold\nAnalysér tekst\nUtforsk lyd og bilder\nLag rapporter og presentasjoner\nPublisér på nett\nBli trygg på R\nIkke stopp her\n\n\n\n\n\n\n\nDiagrammer (kapittel 6).\n\n\n\n\n\nTekstanalyse (kapittel 11)\n\n\n\n\n\nPlansjer (kapittel 13)\n\n\n\n\n\n\n\nKart (kapittel 7).\n\n\n\n\n\nInteraktive 3D-figurer (kapittel 14)\n\n\n\n\n\nNettskraping (kapittel 9)\n\n\n\n\n\n\n\nNettsider (kapittel 14)\n\n\n\n\n\nPene dokumenter (kapittel 13)\n\n\n\n\n\nBildeanalyse (kapittel 12)\n\n\n\n\n\n\n\n\nDiagrammer (kapittel 6).\nTekstanalyse (kapittel 11)\nPlansjer (kapittel 13)\nKart (kapittel 7).\nInteraktive 3D-figurer (kapittel 14)\nNettskraping (kapittel 9)\nNettsider (kapittel 14)\nPene dokumenter (kapittel 13)\nBildeanalyse (kapittel 12)"
  },
  {
    "objectID": "ressurser.html",
    "href": "ressurser.html",
    "title": "Ressurser",
    "section": "",
    "text": "Data\nAll eksempelkode og -data ligger her.\n\n\nR-pakke\nR-pakken rforalle hjelper deg å laste ned eksempelkode og eksempeldata. Installér den med følgende kommando:\n\ndevtools::install_github(\"hegghammer/rforalle\")"
  },
  {
    "objectID": "blogg.html",
    "href": "blogg.html",
    "title": "Blogg",
    "section": "",
    "text": "Hello"
  },
  {
    "objectID": "utdrag.html",
    "href": "utdrag.html",
    "title": "Kapittel 6: Fremstill diagrammer",
    "section": "",
    "text": "FORBEREDELSER\n- Opprett et R-prosjekt kalt kap06 som en undermappe i mappen rbok og jobb derfra. - Installér pakkene du trenger med install.packages(c(\"timelineS\", \"ggplot2\", \"ggeasy\", \"ggimage\", \"forcats\", \"ggraph\", \"DiagrammeR\", \"rsvg\", \"DiagrammeRsvg\", \"devtools\")) og devtools::install_github(\"hegghammer/rforalle\"). - Last ned koden i dette kapittelet med rforalle::hent_kode(\"kap06.R\").\nDet er ikke alt som kan fremstilles med grafer og kurver. For å visualisere kronologier, prosesser, eller relasjoner mellom ting, må vi ty til diagrammer av ulike slag, og her kan R være til stor hjelp. I dette kapittelet skal vi lære hvordan vi kan lage pene tidslinjer, prosessdiagrammer og andre diagramtyper i R. Figur 1 viser noen av illustrasjonene vi skal lage."
  },
  {
    "objectID": "utdrag.html#tidslinjer",
    "href": "utdrag.html#tidslinjer",
    "title": "Kapittel 6: Fremstill diagrammer",
    "section": "Tidslinjer",
    "text": "Tidslinjer\nTenk deg at du er historielærer og trenger en kronologi over kjente slag i vikingtiden. Du kan alltids lage det i Excel, men du vil da være ganske bundet til Excels grafiske uttrykk, og prosessen vil involvere mye klikking som du ikke nødvendigvis husker til neste gang du trenger en tidslinje. Lager du den derimot med kode, er det nesten bare fantasien som setter grenser for det designmessige, og når du trenger en ny, kopierer du bare koden og justerer det som trengs. I R er det lett å lage pene, repliserbare tidslinjer, ikke minst med pakken timelineS.\n\ntimelineS\ntimelineS (merk stavingen med stor S) gjør opptegning av tidslinjer til en lek. Det eneste du trenger er en dataramme med navn på hendelser i én kolonne og datoer i den andre. Du kan lett lage en slik dataramme selv, enten ved å bygge den opp med R-kode (se kapittel 4) eller fylle inn et regneark. Men til dette eksempelet skal vi bruke en CSV-fil som jeg har forberedt og som ligger i dataarkivet under navnet “kap06_slag.csv”. Vi kan laste den ned med rforalle::hent_data() og laste den inn i R med read.csv().\n\nlibrary(rforalle)\nhent_data(\"kap06_slag.csv\")\n\nLaster ned 'kap06_slag.csv' til /home/thomas/gitstuff/gitlab/rbok_nett ..\n\ndf_slag &lt;- read.csv(\"slag.csv\")\n\nDeretter tar vi datarammen nærmere i øyesyn med str() og head() slik vi lærte i forrige kapittel at vi alltid bør gjøre. Om du vil, kan du også se på den med View(df_slag).\n\nstr(df_slag)\nhead(df_slag)\n\nVi ser at df_slag har seks rader og fire kolonner. Hver rad er en hendelse, og for hver rad har vi en hendelsesbeskrivelse (navn), et årstall (år), en lenke til et bilde (bilde) og opphavet til bildet (kunstner). Bildeinformasjonen er overflødig; det er egentlig bare hendelsesbeskrivelsen og årstallet vi trenger akkurat nå.\nDen eneste lille komplikasjonen er at timelineS vil ha tidspunkter som datoer i formatet “ÅÅÅÅ-MM-DD”, mens vår vektor df_slag$år bare inneholder årstall. Men vi kan omforme årstallene til datoer ved å legge til en fiktiv dato, f.eks. 1. juli. Til dette bruker vi bare paste0() og legger til strengen “-07-01”. I tillegg må vi omforme datostrengene våre til datatypen “date” med funksjonen as.Date().\n\ndf_slag$år &lt;- paste0(df_slag$år, \"-07-01\")\ndf_slag$år &lt;- as.Date(df_slag$år)\n\nNå som vi har en kolonne med gyldige datoer, kan vi tegne opp tidslinjen med funksjonen timelineS() (se Figur 2). timelineS() trenger i utgangspunktet bare en dataramme som argument. Så lenge første kolonne er hendelsesbeskrivelser og andre kolonne er datoer, gjør funksjonen resten selv.\n\nlibrary(timelineS)\ntimelineS(df_slag)\n\n\n\n\n\n\n\nFigur 2: Tidslinje i timelineS uten modifikasjoner.\n\n\n\n\n\nVi ser at dette skal være en tidslinje, men det er mye som bør rettes på. Det er for mange vertikale markører langs tidslinjen, og årstallene er ikke runde tall. Vi bør også ta bort datoene fra hendelsesbeskrivelsene og legge på en tittel. Litt farger hadde også gjort seg. Alt dette kan ordnes med parametere inni funksjonen timelineS, for eksempel som følger (se Figur 3):\n\ntimelineS(df_slag,\n  main = \"Kjente slag i vikingtiden\",\n  buffer.days = 8000, # Antall dager forlengelse på hver side\n  line.width = 5, # Tykkelse på tidslinjen\n  line.color = \"darkgreen\", # Farge på tidslinjen\n  scale = \"20 years\", # Intervaller langs tidslinjen\n  scale.cex = 1, # Fontstørrelsen på årstallene langs tidslinjen\n  scale.tickwidth = 3, # Tykkelsen på de vertikale taggene \n  labels = paste(df_slag[[1]]), # Hvilke data som skal utgjøre teksten\n  label.color = \"orange\", # Farge på linjen mellom hovedlinjen og titlene\n  label.cex = 1,\n  point.color = \"red\", # Farge på punktmarkøren\n  )\n\n\n\n\n\n\n\n\n\nFigur 3: Tilpasset tidslinje i timelineS.\n\n\n\n\n\nUnder panseret bruker timelineS funksjonen plot() fra grunninstallasjonen, så vi kan lagre tidslinjen til et bilde ved å kjøre koden igjen mellom png() og dev.off() slik vi lærte i kapittel 5. Koden vil se ut som følger. Merk at hvis du øker bildets bredde og høyde, vil fonten fremstå mindre, og vice-versa.\n\npng(\"tidslinje.png\", width = 1000, height = 600, units = \"px\")\ntimelineS(df_slag,\n  main = \"Kjente slag i vikingtiden\",\n  buffer.days = 8000, # Antall dager forlengelse på hver side\n  line.width = 5, # Tykkelse på tidslinjen\n  line.color = \"darkgreen\", # Farge på tidslinjen\n  scale = \"20 years\", # Intervaller langs tidslinjen\n  scale.cex = 1, # Fontstørrelsen på årstallene langs tidslinjen\n  scale.tickwidth = 3, # Tykkelsen på de vertikale taggene \n  labels = paste(df_slag[[1]]), # Hvilke data som skal utgjøre teksten\n  label.color = \"orange\", # Farge på linjen mellom hovedlinjen og titlene\n  label.cex = 1,\n  point.color = \"red\", # Farge på punktmarkøren\n  )\ndev.off()\n\nIfølge dokumentasjonen til pakken timelineS kan vi gjøre flere andre typer justeringer. Vi kan for eksempel endre tekstens font, farge og vinkel, justere lengden på hver enkel av de vertikale linjene og bestemme hva som skal være over og under hovedlinjen. Når dette er sagt, er vi fortsatt ganske låst til de overordnede designvalgene til utvikleren av timelineS. For å få full kontroll over utseendet til tidslinjen, må vi lage den fra bunnen med ggplot2.\n\n\nggplot2\nÅ lage tidslinje i ggplot2 er litt mer arbeid, men til gjengjeld gir det betydelig større muligheter for tilpasninger. Vi kan prøve å lage en variant av den samme tidslinjen. Her er det viktig å laste inn datarammen på nytt, fordi vi endret på en av variablene (df_slag$år) i forrige del. Hvis du ikke gjør dette, vil du få feilmelding nedenfor.\n\ndf_slag &lt;- read.csv(\"slag.csv\")\n\nEnkelt fortalt involverer prosessen fem steg. Steg 1 er å tegne opp en enkel linje midt på lerretet. Som med alt annet i ggplot2, må vi tenke på lerretet som et koordinatsystem med en x- og en y-akse. Vi står fritt til å definere hva verdiene på disse aksene skal være, så det første vi må gjøre er å bestemme oss for hva yttergrensene på aksene skal være. Siden x-aksen skal bestå av årstall, velger vi et startpunkt som er litt før det laveste årstallet og et sluttpunkt som er litt etter det høyeste årstallet, for eksempel slik:\n\nstart &lt;- 800\nslutt &lt;- 1100\n\nY-aksen, derimot, henger sammen med lengden på de vertikale strekene eller stolpene som skal markere hendelser. Hvilke verdier du setter på y-aksen avhenger av hvor mye variasjon du ser for deg å ha på lengden av disse stolpene. Vi skal bare ha to ulike lengder over og under linjen. I tillegg vil vi ha litt luft over og under, så vi kan tenke at vi skal ha tre nivåer over og under. Vi definerer derfor en variabel som er delelig med tre og kaller den makshøyde. Vi bruker tallet 3 slik at vi får runde tall (1 og 2) når vi skal sette lengden på stolpene.\n\nmakshøyde &lt;- 3\n\nNå kan vi tegne opp lerretet og en enkel linje. For å lage linjen bruker vi geom_segment(), som tar parametrene x og y for punktet hvor linjen starter og xend og yend for punktet hvor linjen slutter. Siden linjen skal gå rett horisontalt, setter vi verdien 0 for både y og yend. For x og xend bruker vi variablene start og slutt som vi nettopp laget. I tillegg legger vi inn parametere for tykkelse og farge på linjen, samt litt kode for å få pilspisser i hver ende.\nFor å tegne y-aksen, bruker vi funksjonen scale_y_continuous() og parameteret limits (se Figur 4). Vi vil at y-aksen skal gå til 3 over linjen og til -3 under linjen, og siden vi har lagret tallet 3 i variabelen makshøyde kan vi bruke den når vi setter verdien limits (vi bare setter et minustegn foran for å få -3). Vi lagrer denne første opptegningen i objektet linje fordi vi skal bygge videre på det etterpå.\n\nlibrary(ggplot2)\nlinje &lt;- ggplot() +\n  geom_segment(aes(x = start, \n                   xend = slutt, \n                   y = 0, \n                   yend = 0\n                   ), \n               linewidth = 1, \n               color = \"purple\", \n               arrow = arrow(ends = \"both\", length = unit(0.3, \"cm\"))\n               ) +\n  scale_y_continuous(limits = c(-makshøyde, makshøyde))\nlinje\n\n\n\n\n\n\n\n\n\nFigur 4: Steg 1 i bygging av tidslinje med ggplot().\n\n\n\n\n\nSteg to er å tegne årstall på linjen og lage små merker eller horisontale tagger for hvert av tallene. Her må vi lage en oss en tallserie med intervaller som samsvarer med avstanden vi ønsker å ha mellom hvert årstall. Vi kan gjøre som i forrige tidslinje og ha 20 år mellom hvert årstall. For å lage tallserien kan vi bruke funksjonen seq(), som tar tre argumenter: første tall, siste tall, og lengden på intervallet. Vi vil imidlertid ikke ha merke på ytterpunktene, for der er det pilspiss, så vi starter i 820 og slutter i 1080.\n\nmerker &lt;- seq(start + 20, slutt -20, 20)\n\nFor å tegne på årstallene, bruker vi funksjonen annotate(), som vi ble introdusert for i forrige kapittel. Når vi skal bruke annotate() til å tegne på tekst, er det tre hovedparametere som gjelder: x og y for stedet hvor teksten skal stå og label for selve teksten som skal påtegnes. Så er det slik at ggplot2-funksjoner som annotate() kan brukes til å sette inn mange ting på én gang, så lenge vi setter inn vektorer som verdier for de aktuelle parametrene. Vi kan derfor sette inn alle tallene i vektoren merker ved å oppgi den som verdi for parameteret label. Siden disse tallene også tilsvarer stedene langs x-aksen hvor tallene skal stå, kan vi bruke merker som verdi for parameteret x. Vi vil ha tallene bittelitt under linjen, så vi setter y til et lavt negativt tall.\nFor å tegne opp merkene langs linjen, bruker vi igjen geom_segment() (se Figur 5). Denne gangen går strekene vertikalt, så verdiene for x og xend skal være de samme, mens verdiene for y og yend må være forskjellige. For å få en liten strek på alle x-verdiene i merker, putter vi bare objektet merker inn som verdi for x og xend. Vi setter y til 0 og yend til et lavt negativt tall ettersom strekene bare skal være en millimeter eller to lange.\n\ntallinje &lt;- linje +\n  annotate(geom = \"text\", \n           x = merker, \n           y = -.2, \n           label = merker, \n           size = 5) +\n  geom_segment(aes(x = merker, \n                   xend = merker, \n                   y = 0, \n                   yend = -.08\n                   ),\n               linewidth = 1, \n               color = \"purple\"\n               )\ntallinje\n\n\n\n\n\n\n\n\n\nFigur 5: Steg 2 i bygging av tidslinje med ggplot().\n\n\n\n\n\nSteg tre er å tegne opp stolpene som skal gå fra hovedlinjen og ut til hendelsesbeskrivelsene. For å tegne disse må vi lage en vektor med tall som spesifiserer hvor langt ut fra hovedlinjen hver vertikale linje skal gå. Denne vektoren, som vi kan kalle høyde, må ha like mange verdier som det er hendelser som skal påtegnes. Verdiene må være mindre enn yttergrensene på y-aksen, altså mindre enn tallet vi satte som makshøyde, dvs 3. Nøyaktig hvilke verdier du velger, avhenger av hvor du vil ha lave og høye stolper. Her kan du prøve deg litt fram, men vi tester med følgende tallserie.\n\nhøyder &lt;- c(1, -1, 2, -2, 1, -1)\n\nVi bruker så disse verdiene inn i geom_segment() en gang til. De går inn som verdier i parameteret yend slik at vi får vertikale streker fra hovedlinjen (y = 0) ut til høydene vi har satt (se Figur 6). For å få strekene på riktig sted langs x-aksen, bruker vi årstallene i kolonnen df_slag$år som verdier for x og xend. Vi vil også ha sirkler der de vertikale strekene møter hovedlinjen; til dette bruker vi geom_point() med df_slag$år som verdier for x.\n\nstolper &lt;- tallinje +  \n  geom_segment(aes(y = 0, \n                   yend = høyder, \n                   x = df_slag$år, \n                   xend = df_slag$år\n                   ), \n               linewidth = .3) +\n  geom_point(aes(x = df_slag$år, y = 0), size = 2)\nstolper\n\n\n\n\n\n\n\n\n\nFigur 6: Steg 3 i bygging av tidslinje med ggplot().\n\n\n\n\n\nSteg fire er å sette på hendelsesbeskrivelsene (se Figur 7). Til dette bruker vi igjen funksjonen annotate(). Den trenger som nevnt x- og y-verdier for å vite hvor den skal plassere teksten. x-verdiene er de samme som for stolpene, altså vektoren df_slag$år. y-verdiene er de samme som høydene på stolpene, altså vektoren høyder. For et litt mer fancy utseende kan vi bruke geom = \"label\" i stedet for geom = \"text\"; dette gir oss tekstbokser rundt teksten.\nFor selve beskrivelsene kan vi også gjøre litt mer ut av det ved å legge til det nøyaktige årstallet for hver hendelse under teksten. Her bruker vi bare paste0() til å lime tekstene sammen med årstallene, med \\n i mellom. Vi lagrer de nye beskrivelsene i en ny vektor som vi så oppgir i parameteret label i annotate().\n\nbeskrivelser &lt;- paste0(df_slag$navn, \"\\n\", df_slag$år)\n\n\ntekst &lt;- stolper +\n  annotate(geom = \"label\", \n           x = df_slag$år, \n           y = høyder, \n           label = beskrivelser, \n           size = 4, \n           label.padding = unit(0.3, \"cm\"), \n           fill = \"wheat\")\ntekst\n\n\n\n\n\n\n\n\n\nFigur 7: Steg 4 i bygging av tidslinje med ggplot().\n\n\n\n\n\nFemte og siste steg er finpussen. Nå kan vi fjerne rutenettet og aksene, legge på tittel og fargelegge bakgrunnen. Vi sentrerer tittelen og gir den større font med hjelpefunksjonene easy_center_title() og easy_plot_title_size() fra pakken ggeasy (se Figur 8}).\n\nlibrary(ggeasy)\ntekst +\n  theme_void() +\n  labs(title = \"\\nKjente slag i vikingtiden\") +\n  easy_center_title() +\n  easy_plot_title_size(30) +\n  theme(plot.background = element_rect(fill = \"lightblue\"))\n\n\n\n\n\n\n\n\n\nFigur 8: Steg 5 i bygging av tidslinje med ggplot().\n\n\n\n\n\nDette er kanskje ikke verdens mest avanserte tidslinje, men nå som vi vet hvordan tidslinjen er bygget opp, er det mye lettere å eksperimentere med andre estetiske uttrykk.\nSom et eksempel kan vi prøve å lage en variant av samme tidslinje, denne gangen med bilder. Vi går tilbake et par steg og bygge videre på grafobjektet stolper, som inneholder tidslinjen og stolpene, uten tekstbeskrivelser. Vi kan sette inn bilder i stedet for beskrivelser ved å bruke funksjonen geom_image() fra pakken ggimage. Den trenger bare x- og y-verdier for de stedene hvor bildene skal settes inn, samt en verdi for parameteret image. Dette kan være en vektor med søkestier til bildefiler på harddisken din eller lenker til bilder et sted på nettet. Her får vi endelig bruk for lenkene i datarammen df_slag; vi putter bare vektoren df_slag$bilde inn som verdi for parameteret image. Og vips har vi en tidslinje med et kunstverk for hvert av slagene (se Figur 9).1\n\nlibrary(ggimage)\nbilder &lt;- stolper +\n  geom_image(aes(x = df_slag$år, \n                 y = høyder, \n                 image = df_slag$bilde\n                 ), \n             size = .2)\nbilder\n\n\n\n\n\n\n\nFigur 9: Tidslinje laget med ggplot() — med bilder.\n\n\n\n\n\nPå nytt bør vi finpusse ved å fjerne rutenettet og legge på farger. I tillegg må vi anerkjenne opphavet til bildene. Det er lett å gjøre ettersom kunstnernavnene er lagret i datarammen df_slag. Vi bruker paste() til å bygge en streng som kan fungere som opphavsnotis.\n\nopphav &lt;- paste(\"Kunstnere: \\n\", \n                paste(df_slag$kunstner, collapse = \"\\n\")\n                )\n\nDeretter benytter vi samme kode som sist, men vi legger til funksjonen annotate() og plasserer opphavsteksten nede til venstre på figuren ved hjelp av parametrene x og y (se Figur 10).\n\nbilder +\n  theme_void() +\n  labs(title = \"\\nKjente slag i vikingtiden\") +\n  easy_center_title() +\n  easy_plot_title_size(30) +\n  theme(plot.background = element_rect(fill = \"mistyrose\")) +\n  annotate(geom = \"text\", \n           x = 840, \n           y = -1.7, \n           label = opphav, \n           size = 5)\n\n\n\n\n\n\n\n\n\nFigur 10: Tidslinje laget med ggplot() — med bilder og tilpasninger."
  },
  {
    "objectID": "utdrag.html#gantt-diagrammer-med-ggplot2",
    "href": "utdrag.html#gantt-diagrammer-med-ggplot2",
    "title": "Kapittel 6: Fremstill diagrammer",
    "section": "Gantt-diagrammer med ggplot2",
    "text": "Gantt-diagrammer med ggplot2\nEn av tidslinjens nærmeste slektninger er Gantt-diagrammet. Du kjenner det fra søknader og prosjektbeskrivelser: horisontale og delvis overlappende søyler som viser når ulike faser i prosjektet er ment å være ferdig. Men Gantt-diagrammer kan brukes til mye annet, for eksempel til historieformidling. I det følgende skal vi lage et diagram som viser når og hvor lenge de første norske vikingkongene levde.\nDet er flere måter å lage Gantt-diagrammer på i R, men den mest fleksible og robuste er med ggplot2.2 Til dette trenger vi en dataramme som er formatert på en hensiktsmessig måte. Ettersom kjernen i Gantt-diagrammer er tidsperioder, trenger vi en dataramme med minst tre kolonner: 1) navnet på periodene, 2) startpunktene og 3) sluttpunktene. Overført til vårt eksempel trenger vi altså en dataramme med navnet på kongene, deres fødselsår og deres dødsår.\nI bokens dataarkiv ligger det en fil kalt “kap06_konger.csv” med navn, estimert fødselsår og dødsår på syv konger fra Harald Hårfagre til Olav Haraldsson. Vi kan laste den ned med hent_data() og inn i R med read.csv().\n\nhent_data(\"kap06_konger.csv\")\n\nLaster ned 'kap06_konger.csv' til /home/thomas/gitstuff/gitlab/rbok_nett ..\n\ndf_konger &lt;- read.csv(\"konger.csv\")\n\nIgjen inspiserer vi med str() og head() for å være sikre på at vi har riktige data.\n\nstr(df_konger)\nhead(df_konger)\n\nNå kan opptegningen begynne. Planen er å få en horisontal søyle for hver av kongene, og denne søylen skal starte ved fødselsåret og slutte ved dødsåret. I sluttversjonen skal x-aksen derfor ha årstall, mens y-aksen skal ha kongenavnene. For å lage søyler kan vi bruke funksjonen geom_segment(), som vi brukte en del når vi laget tidslinje. Vi husker at geom_segment() trenger fire parametere: x, xend, y og yend.\nForskjellen denne gangen er at den ene variabelen (“år”) består av tall, mens den andre (“navn”) består av tekst. I et koordinatsystem vil de oppføre seg annerledes, fordi en tekstvariabel ikke har en åpenbar matematisk rekkefølge, mens en tallvariabel har det. I forbindelse med grafer kaller man tallvariabler for kontinuerlige variabler (eng. continuous variables) og tekstvariabler for diskrete variabler (eng. discrete variables). Du kan også tenke på diskrete variabler som kategorier.\nNår vi har en kombinasjon av diskrete og kontinuerlige variabler slik som her, er det god praksis å starte med å knytte den diskrete variabelen til x-aksen og den kontinuerlige til y-aksen selv om vi til slutt skal ha det omvendt. Det er fordi ggplot2 i noen tilfeller kan oppføre seg rart hvis y-variabelen ikke er kontinuerlig.\nVi starter derfor med å knytte x-parametrene i geom_segment() til df_konger$navn og y-parametrene til henholdsvis df_konger$født og df_konger$død som følger (se Figur 11).\n\nlibrary(ggplot2)\nggplot(data = df_konger) +\n  geom_segment(aes(x = navn, xend = navn, y = født, yend = død))\n\n\n\n\n\n\n\nFigur 11: Første steg i bygging av Gantt-diagram med ggplot().\n\n\n\n\n\nMen vi ville jo ha navnene på venstre side, altså på y-aksen. For å få det til, brker vi den fiffige funksjonen coord_flip() som bytter om på x og y aksen slik at figuren fremstår som vridd 90 grader (se Figur 12).\n\nggplot(data = df_konger) +\n  geom_segment(aes(x = navn, xend = navn, y = født, yend = død)) +\n  coord_flip()\n\n\n\n\n\n\n\nFigur 12: Andre steg i bygging av Gantt-diagram med ggplot().\n\n\n\n\n\nVi er på rett spor, men mye gjenstår. Vi ser blant annet at navnene er stokket om; R har satt dem i alfabetisk rekkefølge etter fornavn, nedenfra og opp. Dette er noe ggplot2 gjør automatisk med tekstvektorer, og for å unngå det må vi gjøre strengene i vektoren om til det som kalles “faktorer”, det vil si kategorier som ikke kan flyttes på. Dette gjøres enklest med funksjonen fct_inorder() fra pakken forcats. Den “fryser” rekkefølgen til en vektor slik den står i den opprinnelige datarammen. Vi skal komme nærmere tilbake til temaet faktorer i kapittel 11.\n\nlibrary(forcats)\ndf_konger$navn &lt;- fct_inorder(df_konger$navn)\n\nHvis vi nå kjører samme kommando som tidligere, er navnene i riktig rekkefølge (se Figur 13):\n\nggplot(data = df_konger) +\n  geom_segment(aes(x = navn, xend = navn, y = født, yend = død)) +\n  coord_flip()\n\n\n\n\n\n\n\nFigur 13: Gantt-diagram laget med ggplot() — med navn i endret rekkefølge.\n\n\n\n\n\nKanskje er det mest logisk å ha den første kongen øverst. La oss derfor snu om på rekkefølgen i navneaksen. ggplot2 har et sett med funksjoner som lar oss manipulere akser; vi brukte to av dem — scale_x_continuous() scale_y_continuous() — i forrige kapittel. For diskrete variabler slik som kongenavnene våre må vi bruke scale_x_discrete() eller scale_y_discrete(). Siden vi knyttet navnene til x-verdiene, bruker vi scale_x_discrete(). For å snu om på rekkefølgen i verdiene (altså navnene) setter vi uttrykket limits = rev (for reverse) mellom parentesene. (se Figur 14):\n\nggplot(data = df_konger) +\n  geom_segment(aes(x = navn, xend = navn, y = født, yend = død)) +\n  coord_flip() +\n  scale_x_discrete(limits = rev)\n\n\n\n\n\n\n\nFigur 14: Gantt-diagram laget med ggplot() — med navn i snudd rekkefølge.\n\n\n\n\n\nSå må vi endre linjene/søylene, og det gjør vi med parametere inni geom_segment(). Vi kan øke bredden med linewidth og endre fargen med color (se Figur 15).\n\ngantt_farger &lt;- ggplot(data = df_konger) +\n  geom_segment(aes(x = navn, xend = navn, y = født, yend = død),\n               linewidth = 10, \n               color = \"purple\") +\n  coord_flip() +\n  scale_x_discrete(limits = rev)\ngantt_farger\n\n\n\n\n\n\n\nFigur 15: Gantt-diagram laget med ggplot() — med modifiserte søyler.\n\n\n\n\n\nFinpussen gjenstår. Vi bør blant annet legge til hovedtittel og fjerne aksetitlene med funksjonen labs(). Vi kan også gjøre x-aksen om til en tydelig tidslinje. Det gjør vi med funksjonen theme() og diverse parametere som starter med axis.*. Vi trenger ikke gå inn på detaljene her; bare noter at hver minste detalj ved plottet kan justeres.3 Til slutt kan vi endre bakgrunnsfargen og rutenettet med parametere som starter med panel.* inni theme(). La oss se hvordan dette blir (se Figur 16):\n\ngantt_ferdig &lt;- gantt_farger +\n  labs(title = \"Når levde de første norske kongene?\", x = \"\", y = \"\") +\n  theme(axis.line.x = element_line(linewidth = 1),\n        axis.text.x = element_text(size = 10, face = \"bold\"),\n        axis.ticks.x = element_line(linewidth = .5),\n        axis.ticks.length.x = unit(.5, \"cm\"),\n        panel.background = element_rect(fill = \"lavenderblush2\"),\n        panel.grid.major.x = element_line(color = \"grey80\"),\n        panel.grid.minor.x = element_line(color = \"grey80\"),\n        panel.grid.major.y = element_blank()\n        )\ngantt_ferdig\n\n\n\n\n\n\n\nFigur 16: Gantt-diagram laget med ggplot() — med endret bakgrunn og akse.\n\n\n\n\n\nVi kan også prøve å lage en litt annen variant hvor navnene står inni søylene og ikke i en liste til venstre. Det kan vi få til med funksjonen annotate(), som plasserer det man vil hvor man vil på figuren. Men for å få navnene midt i de brune feltene, må vi lage en ny vektor med verdier for sentrum av hvert segment. Det er ren matematikk og kan formuleres slik:\n\ndf_konger$midten &lt;- df_konger$født + (df_konger$død - df_konger$født) / 2\n\nLa oss inspisere datarammen for å se om det ble riktig:\n\ndf_konger\n\n              navn født  død midten\n1  Harald Hårfagre  850  931  890.5\n2    Eirik Blodøks  885  954  919.5\n3   Håkon den gode  918  961  939.5\n4   Harald Gråfell  935  970  952.5\n5 Håkon Sigurdsson  935  995  965.0\n6 Olav Tryggvasson  963 1000  981.5\n7  Olav Haraldsson  995 1030 1012.5\n\n\nDa kan vi plotte inn navnene med annotate() samt fjerne navnene fra y-aksen med noen ekstraparametere i theme() (se Figur 17). Vi bør også endre fargen på søylene slik at teksten blir synlig. Vi kan også endre fargen på borden rundt plottet med parameteret plot.background i theme(). Vi kan rekapitulere og ta med koden helt fra start.\n\nggplot(data = df_konger) +\n  geom_segment(aes(x = navn, xend = navn, y = født, yend = død),\n               linewidth = 10,\n               color = \"darkgoldenrod1\") +\n  coord_flip() +\n  scale_x_discrete(limits = rev) +\n  annotate(geom = \"text\", \n           x = df_konger$navn,\n           y = df_konger$midten,\n           label = df_konger$navn, \n           color = \"black\",\n           fontface = \"bold\",\n           size = 2) +\n  labs(title = \"Når levde de første norske kongene?\", x = \"\", y = \"\") +\n  theme(axis.line.x = element_line(linewidth = 1),\n        axis.text.x = element_text(size = 10, face = \"bold\"),\n        axis.ticks.x = element_line(linewidth = .5),\n        axis.ticks.length.x = unit(.5, \"cm\"),\n        panel.background = element_rect(fill = \"grey95\"),\n        panel.grid.major.x = element_line(color = \"grey80\"),\n        panel.grid.minor.x = element_line(color = \"grey80\"),\n        panel.grid.major.y = element_blank(),\n        axis.text.y = element_blank(), \n        axis.ticks.y = element_blank(),\n        plot.background = element_rect(fill = \"wheat\"),\n        )\n\n\n\n\n\n\n\nFigur 17: Gantt-diagram laget med ggplot() — med annoteringer.\n\n\n\n\n\nIkke fortvil hvis dette virker komplisert. Det tar tid å lære seg hvilke kommandoer som endrer hva i ggplot2 og ikke minst hva alle parametrene som kan settes inn i theme() heter. Men når du får det inn i fingrene, har du et svært nyttig verktøy til disposisjon."
  },
  {
    "objectID": "utdrag.html#dendrogrammer-med-ggraph",
    "href": "utdrag.html#dendrogrammer-med-ggraph",
    "title": "Kapittel 6: Fremstill diagrammer",
    "section": "Dendrogrammer med ggraph",
    "text": "Dendrogrammer med ggraph\nHittil har vi jobbet mest med grafer og diagrammer som representerer noe kronologisk. En annen viktig kategori diagrammer beskriver relasjoner mellom ting, for eksempel genetiske relasjoner, konseptuelle sammenhenger, prosesser eller nettverk.\nLa oss si vi ville lage et slektstre som viser hvordan de tidlige norske vikingkongene sto i slektsmessig forhold til hverandre. Til dette kan vi bruke et såkalt dendrogram, som det er god støtte for i R, blant annet fordi mange biologer bruker R.\nDendrogrammer kan lages på flere måter, men vi skal bruke pakken ggraph, som er en generell verktøykasse for fremstilling av relasjonsdata. ggraph har den fordelen at den bruker omtrent samme syntaks som ggplot2, så vi slipper å lære enda en ny måte å lage figurer på.\nHer igjen er det struktureringen av datarammen som er det vanskeligste. For å lage dendrogram med ggraph må vi ha en dataramme bestående av rader som representerer parvise relasjoner — det som i nettverksanalyse kalles “kanter” (eng. edges). En kant består av to “noder”; én i hver ende av kanten. Datarammen må derfor ha to kolonner, én for startnoden og én for sluttnoden. Disse kolonnene må ha navnet “from” og “to” for at ggraph skal kunne lese datarammen.\nI bokens dataarkiv ligger det en CSV-fil kalt “kap06_slekt.csv” som er ferdig formatert til dette formålet. Datarammen inneholder relasjondata fra den såkalte Hårfagreætta, nærmere bestemt de fire generasjonene fra Halvdan Svarte via Harald Hårfagre ned til sistnevntes barnebarn. Det er langt fra en komplett fremstilling, for av Harald Hårfagres over 20 barn har jeg bare tatt med Eirik Blodøks og Håkon den Gode, siden det var de som fikk kongemakt.\nLa oss laste ned filen med hent_data() og se hvordan en relasjonsdataramme ser ut inni.\n\nhent_data(\"kap06_slekt.csv\")\n\nLaster ned 'kap06_slekt.csv' til /home/thomas/gitstuff/gitlab/rbok_nett ..\n\ndf_rel &lt;- read.csv(\"slekt.csv\")\ndf_rel\n\n              from                 to\n1   Halvdan Svarte    Harald Hårfagre\n2  Harald Hårfagre      Eirik Blodøks\n3  Harald Hårfagre     Håkon den Gode\n4    Eirik Blodøks      Guttorm Gamle\n5    Eirik Blodøks     Harald Gråfell\n6    Eirik Blodøks Ragnfred Eiriksson\n7    Eirik Blodøks   Erling Eiriksson\n8    Eirik Blodøks   Gudrød Eiriksson\n9    Eirik Blodøks       Sigurd Sleva\n10  Håkon den Gode     &lt;Ingen sønner&gt;\n\n\nHer har vi altså ti rader, en for hver kant (dvs. bilaterale relasjon).\nNøkkelfunksjonen i pakken ggraph heter simpelthen ggraph(), og den tar en dataramme som hovedargument. I likhet med ggplot() genererer ikke ggraph() alene noen figur; vi må plusse på en geom_*-funksjon som spesifiserer hvilken grafikk vi ønsker. I ggraph-systemet heter disse funksjonene som oftest noe med geom_edge_* og geom_node_*. Vi skal bruke geom_edge_diagonal(), som tegner avrundete streker mellom nodene (se Figur 18).\n\nlibrary(ggraph)\nggraph(df_rel, layout = \"auto\") + \n  geom_edge_diagonal()\n\nUsing \"tree\" as default layout\n\n\n\n\n\n\n\n\nFigur 18: Enkelt dendrogram laget med ggraph().\n\n\n\n\n\nVi ser at ggraph() og geom_edge_diagonal() gir oss diagrammets skjelett — altså forbindelsene mellom nodene uten nodenes navn. For å vise navnene må vi plusse på enten geom_node_text() eller geom_node_label(). Den første legger bare til tekst, den andre legger til tekst med en tekstboks rundt. Vi må også fortelle R hvor disse funksjonene skal hente teksten fra, og det gjør vi ved å sette uttrykket aes(label = name) mellom parentesene (se Figur 19). Vi kan også justere fontstørrelse, skriftstørrelse og andre ting med parametere inni geom_node_label(). Vi setter size = 2 for at ikke boksene skal overlappe.\n\nggraph(df_rel, layout = \"auto\") + \n  geom_edge_diagonal() + \n  geom_node_label(aes(label = name), size = 2)\n\nUsing \"tree\" as default layout\n\n\n\n\n\n\n\n\nFigur 19: Dendrogram laget med ggraph() — med tekstbokser.\n\n\n\n\n\nVi vil også ha mer luft rundt diagrammet slik at alt kommer med. Det gjør vi med funksjonene scale_x_continuous() og scale_y_continuous() og parameteret limits. Men hva skal yttergrensene være? Vi ser at diagrammet vårt er syv noder bredt og fire noder høyt, noe som betyr at x-koordinatene i utgangspunktet går fra 0 til 6 og y-koordinatene går fra 0 til 3. Hvis vi tar en noe lavere minimumsverdi og litt høyere maksverdi, vil “lerretet” bli større. Vi kan også legge til en tittel med funksjonen labs() (se Figur 20).\n\nggraph(df_rel, layout = \"dendrogram\") + \n  geom_edge_diagonal() + \n  geom_node_label(aes(label = name), size = 2) +\n  scale_x_continuous(limits = c(-0.2,6.2)) +\n  scale_y_continuous(limits = c(-0.2,3.2)) +\n  labs(title = \"Hårfagreætta\")\n\n\n\n\n\n\n\nFigur 20: Dendrogram laget med ggraph() — med ryddige tekstbokser.\n\n\n\n\n\nOg vips har vi et ferdig trediagram. Det er mye mer vi kan gjøre, for de fleste funksjonene som modifiserer ggplot-figurer fungerer også på ggraph-figurer, så jo mer du lærer om ggplot, jo lettere vil det bli å finpusse ggraph-diagrammer.\nFor læringens skyld kan vi gjøre ytterligere et par justeringer. Det ene er å endre farge og tykkelse på linjen mellom nodene. Det gjør vi med parametrene width og color inni funksjonen geom_edge_diagonal().\nDet andre er å fargelegge tekstboksene selektivt for å skille mellom de som ble konger og de som ikke ble det. Her må vi bruke parameteret fill inni geom_node_label(). Å få samme farge på alle tekstboksene er lett; det er bare å sette fill til én bestemt farge (f. eks. fill = \"grey\"). Å få forskjellige farger er litt mer krevende. Da må vi lage en vektor med fargekoder — én for hver tekstboks — og så oppgi denne vektoren som verdi til parameteret fill.\nFor at dette skal fungere, må hver tekstboks være representert i vektoren med hver sin tiltenkte fargekode. Vi må også vite at R begynner å telle ovenfra og teller fra venstre mot høyre, så det første elementet i vektoren representerer noden Halvdan Svarte, den fjerde representerer Håkon den Gode, osv. Vi vet at bare de fire første samt Harald Gråfell ble konger, så vi gir disse en egen farge.\n\nfarger &lt;- c(\"gold2\", \"gold2\", \"gold2\", \"gold2\", \"grey\", \"gold2\", \"grey\", \"grey\", \"grey\", \"grey\", \"white\")\n\nNå kan vi tegne opp diagrammet (se Figur 21):\n\nggraph(df_rel, layout = \"dendrogram\") + \n  geom_edge_diagonal(width = 0.5, color = \"grey\") + \n  geom_node_label(aes(label = name), \n                  size = 2, \n                  fill = farger) +\n  scale_x_continuous(limits = c(-0.2,6.2)) +\n  scale_y_continuous(limits = c(-0.2,3.2)) +\n  labs(title = \"Hårfagreætta\")\n\n\n\n\n\n\n\nFigur 21: Dendrogram laget med ggraph() — med fargede bokser.\n\n\n\n\n\n\nFør vi går videre kan vi ta en rask titt på hvor lett det er å endre diagramstruktur i ggraph. For å snu diagrammet opp-ned, kan vi endre layout-parameteret i ggraph()-funksjonen fra “dendrogram” til “partition” (se Figur 22):\n\nggraph(df_rel, layout = \"partition\") + \n  geom_edge_diagonal()\n\n\n\n\n\n\n\nFigur 22: Dendrogram laget med ggraph() — snudd 180 grader.\n\n\n\n\n\nFor å snu det 90 grader, plusser vi på coord_flip() (se Figur 23):\n\nggraph(df_rel, layout = \"dendrogram\") + \n  geom_edge_diagonal() +\n  coord_flip() \n\n\n\n\n\n\n\nFigur 23: Dendrogram laget med ggraph() — snudd 90 grader.\n\n\n\n\n\n\nHvis vi bytter ut geom_edge_diagonal() med geom_edge_bend(), får vi andre kurver (se Figur 24):\n\nggraph(df_rel, layout = \"dendrogram\") + \n  geom_edge_bend()\n\n\n\n\n\n\n\nFigur 24: Dendrogram laget med ggraph() — med hardere kurver.\n\n\n\n\n\ngeom_edge_link gir skarpe vinkler (se Figur 25):\n\nggraph(df_rel, layout = \"dendrogram\") + \n  geom_edge_link()\n\n\n\n\n\n\n\nFigur 25: Dendrogram laget med ggraph() — med vinkler.\n\n\n\n\n\n\nMens geom_edge_elbow gir helt rette vinkler (se Figur 26):\n\nggraph(df_rel, layout = \"dendrogram\") + \n  geom_edge_elbow()\n\n\n\n\n\n\n\nFigur 26: Dendrogram laget med ggraph() — med rette vinkler."
  },
  {
    "objectID": "utdrag.html#prosessdiagrammer-med-mermaid",
    "href": "utdrag.html#prosessdiagrammer-med-mermaid",
    "title": "Kapittel 6: Fremstill diagrammer",
    "section": "Prosessdiagrammer med Mermaid",
    "text": "Prosessdiagrammer med Mermaid\nVi kan også bruke R til å lage prosessdiagrammer. La oss si vi ville fremme et argument om at kristendommen svekket toktkulturen i vikingsamfunnene via tre ulike mekanismer — normer mot slaveri, solidaritet med andre kristne og insentiver for handel. Da kunne det passe med et prosessdiagram som går i diamantform fra årsaken via mekanismene til utfallet; altså en boks til venstre (eller oppe), tre bokser i midten, og en boks til høyre (eller nede) (se Figur 27).\n\n\n\n\n\n\n  graph LR\n    A --&gt; B\n    A --&gt; C\n    A --&gt; D\n    B --&gt; E\n    C --&gt; E\n    D --&gt; E\n    A(Kristendom)\n    B(Normer mot slaveri)\n    C(Solidaritet med andre kristne)\n    D(Insentiver for handel)\n    E(Færre tokt)\n\n\n\n\nFigur 27: Mermaid-diagram over hypotetisk årsakskjede.\n\n\n\n\n\nDet er fullt mulig å lage en slik figur med ggplot eller ggraph, men det enkleste er å bruke diagramopptegningsspråket Mermaid via R-pakken DiagrammeR.DiagrammeR (merk stavingen med stor D og S) er en pakke som ikke lager diagrammer på egen hånd, men tjener som budbringer (såkalt wrapper) mellom R og andre, mer spesialiserte diagrambyggingsspråk, nærmere bestemt Mermaid og GraphViz/DOT. Vi skal fokusere på Mermaid fordi det er enklere og kan brukes direkte i Quarto (se kapittel 13).\nR-dimensjonen ved DiagrammeR er veldig enkel; du bruker bare funksjonen DiagrammeR() og setter Mermaid-koden inni, som følger.\n\n## Not Run\nDiagrammeR(\"\n  &lt;MERMAID-KODE HER&gt;\n  \")\n\nMermaid er eget oppmarkeringsspråk for diagrammer og figurer. Du kan tenke på det som en slags Markdown (se kapittel 13) for diagrammer. Det er lett å lære, har utrolig mange funksjonaliteter, og kan brukes på tvers av kodespråk og tekniske plattformer. Du finner en god innføring i Mermaids syntaks på https://mermaid.js.org/intro/.\nDen beste måten å lære Mermaid på er å eksperimentere i en live Mermaid-redigerer slik som https://mermaid.live, for den lar deg se sluttproduktet mens du skriver. Når jeg skal lage et diagram, pleier jeg å skrive Mermaidkoden i en slik redigerer først, for så å lime den inn der jeg trenger den, om det er i et R-skript eller et Quarto-dokument.\nDet er lett å lage prosessdiagrammer i Mermaid fordi koden likner på diagrammet du får. For å tegne to bokser A og B med pil fra A til B (se Figur 28), tegner du bokstavelig talt bare en pil, som følger.\n# Skrives i https://mermaid.live\ngraph LR\n  A --&gt; B\n\n\n\n\n\n\ngraph LR\n  A --&gt; B\n\n\n\n\nFigur 28: Enkelt Mermaid-diagram.\n\n\n\n\n\nFor å få et prosessdiagram må første linje inneholde ordet graph. Bak graph setter vi retningen som pilene skal følge; enten LR (left-to-right), TB (top-to-bottom), RL eller BT. Deretter definerer vi alle kantene i diagrammet, altså relasjonene mellom nodene, én etter én. Resultatet blir som i Figur 29.\n# Skrives i https://mermaid.live\ngraph LR\n  A --&gt; B\n  A --&gt; C\n  B --&gt; D\n  C --&gt; D\n\n\n\n\n\n\ngraph LR\n  A --&gt; B\n  A --&gt; C\n  B --&gt; D\n  C --&gt; D\n\n\n\n\nFigur 29: Mermaid-diagram med flere noder.\n\n\n\n\n\nVi kan bestemme teksten inni nodene (se Figur 30) ved å legge til definisjoner med klammer for hver av nodene.\n# Skrives i https://mermaid.live\ngraph LR\n  A --&gt; B\n  A --&gt; C\n  B --&gt; D\n  C --&gt; D\n  A[DiagrammeR]\n  B[Mermaid]\n  C[GraphViz]\n  D[Diagram]\n\n\n\n\n\n\ngraph LR\n  A --&gt; B\n  A --&gt; C\n  B --&gt; D\n  C --&gt; D\n  A[DiagrammeR]\n  B[Mermaid]\n  C[GraphViz]\n  D[Diagram]\n\n\n\n\nFigur 30: Mermaid-diagram med tekst i nodene.\n\n\n\n\n\nMerk at Mermaid er svært lite følsom for mellomrom og rekkefølge. Du kan sette ting hvor du vil, så fremt de står på separate linjer (se Figur 31).\n# Skrives i https://mermaid.live\ngraph LR\nA[Mermaid]\nA--&gt;B\n         B[Diagram]\n\n\n\n\n\n\ngraph LR\nA[Mermaid]\nA--&gt;B\n         B[Diagram]\n\n\n\n\nFigur 31: Mermaid-diagram fra rotete kode.\n\n\n\n\n\nFormen på nodene kontrolleres med typen klammer i tekstdefinisjonen. Nodenes farge, linjetype, font mm. defineres separat med kommandoen style (se Figur 32). Merk at det finnes mange flere stylingmuligheter enn det jeg viser her.\n# Skrives i https://mermaid.live\ngraph LR\n  A --&gt; B\n  A --&gt; C\n  B --&gt; D\n  C --&gt; D\n\n  A(DiagrammeR)\n  B[Mermaid]\n  C[(GraphViz)]\n  D{Diagram}\n\n  style B fill:yellow,stroke-dasharray: 5 5\n\n\n\n\n\n\ngraph LR\n  A --&gt; B\n  A --&gt; C\n  B --&gt; D\n  C --&gt; D\n  A(DiagrammeR)\n  B[Mermaid]\n  C[(GraphViz)]\n  D{Diagram}\n  style B fill:yellow,stroke-dasharray: 5 5\n\n\n\n\nFigur 32: Mermaid-diagram med modifiserte noder.\n\n\n\n\n\nDu kan endre linjetype med andre typer tegn i kantdefinisjonene (se Figur 33). Farge og andre aspekter ved linjen defineres separat med linkStyle etterfulgt av indeksnummeret til kanten/linjen.4 Den du har definert først blir indeks 0.\n# Skrives i https://mermaid.live\ngraph LR\n  A --- B\n  A -.- C\n  B &lt;--&gt; D\n  C --Tekst--&gt; D\n\n  A(DiagrammeR)\n  B[Mermaid]\n  C[(GraphViz)]\n  D{Diagram}\n\n  style B fill:yellow,stroke-dasharray: 5 5\n  linkStyle 0 stroke:red\n  linkStyle 2 stroke:green\n\n\n\n\n\n\ngraph LR\n  A --- B\n  A -.- C\n  B &lt;--&gt; D\n  C --Tekst--&gt; D\n\n  A(DiagrammeR)\n  B[Mermaid]\n  C[(GraphViz)]\n  D{Diagram}\n\n  style B fill:yellow,stroke-dasharray: 5 5\n  linkStyle 0 stroke:red\n  linkStyle 2 stroke:green\n\n\n\n\nFigur 33: Mermaid-diagram med modifiserte linjer.\n\n\n\n\n\nMed dette kan vi lage et diagram over vår påståtte sammenheng mellom kristendom og toktkultur. Vi putter Mermaid-koden inn i DiagrammeR() slik at vi kan kjøre den i R. Figur 34 viser sluttproduktet.\n\nDiagrammeR(\"\n  graph LR\n    A --&gt; B\n    A --&gt; C\n    A --&gt; D\n    B --&gt; E\n    C --&gt; E\n    D --&gt; E\n    A(Kristendom)\n    B(Normer mot slaveri)\n    C(Solidaritet med andre kristne)\n    D(Insentiver for handel)\n    E(Færre tokt)\n\")\n\n\n\n\n\n\n\n  graph LR\n    A --&gt; B\n    A --&gt; C\n    A --&gt; D\n    B --&gt; E\n    C --&gt; E\n    D --&gt; E\n    A(Kristendom)\n    B(Normer mot slaveri)\n    C(Solidaritet med andre kristne)\n    D(Insentiver for handel)\n    E(Færre tokt)\n\n\n\n\nFigur 34: Mermaid-diagram over hypotetisk årsakskjede.\n\n\n\n\n\nMerk at DiagrammeR() genererer figurer i HTML-format, så du kan ikke bruke funksjonen når du skal lage PDF-dokumenter i Quarto. Men Quarto lar deg skrive Mermaid-kode i egne Mermaid-kodeblokker slik at behovet for DiagrammeR i praksis bortfaller (se kapittel 13)."
  },
  {
    "objectID": "utdrag.html#nettverksdiagrammer-med-ggraph",
    "href": "utdrag.html#nettverksdiagrammer-med-ggraph",
    "title": "Kapittel 6: Fremstill diagrammer",
    "section": "Nettverksdiagrammer med ggraph",
    "text": "Nettverksdiagrammer med ggraph\nVi kan også bruke R til å fremstille nettverk av ulike slag, det være seg mellom personer eller organisasjoner. Nettverksanalyse er et komplisert felt som vi ikke skal gå inn på her, men vi kan se raskt på hvordan vi kan lage enkle nettverksdiagrammer med pakken ggraph.5\nIgjen må vi starte med å bygge en dataramme med grunnlagsdata. En utfordring her er at nettverksdiagrammer ofte involverer mer data enn andre diagrammer. De har gjerne mange noder, og siden hver node kan ha flere kanter, kan datarammen fort bli ganske stor. I praksis lager man sjelden datarammer for nettverksdiagrammer for hånd; man laster ferdige datasett fra andre steder eller genererer dem programmatisk fra andre datakilder.\nFor illustrasjonens skyld har jeg forberedt et lite nettverksdatasett som ligger i bokens dataarkiv under navnet “kap06_nettverk.csv”. Det inneholder forbindelser mellom personer rundt vikinghøvdingen Tore Hund på Bjarkøy på starten av 1000-tallet. Jeg laget det basert på informasjon om Wikipedia-artikkelen om Tore Hund.6 La oss laste det ned og se på øverste del av det med head().\n\nlibrary(rforalle)\nhent_data(\"kap06_nettverk.csv\")\n\nLaster ned 'kap06_nettverk.csv' til /home/thomas/gitstuff/gitlab/rbok_nett ..\n\ndf_nettverk &lt;- read.csv(\"nettverk.csv\")\nhead(df_nettverk)\n\n       from                 to    type\n1 Tore Hund   Tore fra Bjarkøy familie\n2 Tore Hund    Sigurd Toresson familie\n3 Tore Hund Sigrid Toresdatter familie\n4 Tore Hund    Olav Haraldsson  fiende\n5 Tore Hund            Ranveig familie\n6 Tore Hund      Kalv Arnesson partner\n\n\nVi ser at det er strukturert på samme måte som datarammene vi brukte tidligere til ggraph-diagrammer: kanter som rader og to kolonner kalt “from” og “to”. I tillegg har vi nå en kolonne kalt “type”, hvor jeg har kodet for typen relasjon mellom personene, siden dette er noe som egner seg for framstilling i nettverksdiagrammer.\nVi gir datarammen til funksjonen ggraph() for opptegning. For å få nettverksdiagram setter vi parameteret layout til stress. Vi bruker geom_edge_link() for å få rette streker. For å fargelegge forbindelsene etter type, setter jeg inn en aes()-funksjon i geom_edge_link() og assosierer parameteret color med variabelen type. Jeg velger farger med funksjonen scale_edge_color_manual(). I tillegg lager jeg en tittel med labs() og gjør rom rundt nettverket med scale_x_continuous() og scale_y_continuous() (se Figur 35).\n\nggraph(df_nettverk, layout = 'stress') +\n  geom_edge_link(aes(color = type)) +\n  geom_node_point() +\n  geom_node_label(aes(label = name), size = 2) +\n  scale_edge_color_manual(values = c('green3', 'red', 'blue')) +\n  labs(title = 'Tore Hunds verden') +\n  scale_x_continuous(limits = c(-2,2)) +\n  scale_y_continuous(limits = c(-2,2.5))\n\nWarning: Removed 5 rows containing non-finite outside the scale range\n(`stat_edge_link()`).\n\n\nWarning: Removed 3 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\nWarning: Removed 3 rows containing missing values or values outside the scale range\n(`geom_label()`).\n\n\n\n\n\n\n\n\nFigur 35: Nettverksdiagram i ggraph.\n\n\n\n\n\nSå enkelt kan det gjøres hvis man bare har datarammen klar. Diagrammet kan formateres videre med andre ggraph og ggplot2-funksjoner, men vi stopper her, siden hensikten bare var å illustrere prinsippet.\nFør vi avslutter kan vi renske opp i arbeidsområdet vårt med følgende kommando.\n\n# Opprensking\nkan_slettes &lt;- list.files(pattern = 'csv$|png$')\nfile.remove(kan_slettes)"
  },
  {
    "objectID": "utdrag.html#oppsummering",
    "href": "utdrag.html#oppsummering",
    "title": "Kapittel 6: Fremstill diagrammer",
    "section": "Oppsummering",
    "text": "Oppsummering\nVi har lært å lage fem forskjellige diagramtyper: tidslinjer, Gantt-diagrammer, dendrogrammer, prosessdiagrammer og nettverksdiagrammer. Vi har sett at det finnes pakker spesiallaget for én diagramtype (timelineS), at ggraph kan brukes til flere typer relasjonsdiagrammer, og at vi egentlig kan lage alle diagramtyper i ggplot2. På ny har vi sett at hovedutfordringen ofte er å få strukturert underlagsdataene riktig, særlig i ggraph, hvor vi må tenke på de nye begrepene “noder” og “kanter”. Vi har naturligvis ikke dekket alle mulige diagramtyper, men med verktøyene du nå har lært er du godt rustet til å eksperimentere videre på egen hånd. Du lurer kanskje på hvorfor vi ikke har omtalt en av de mest grunnleggende diagramtypene, nemlig tabeller, men det er fordi vi skal gjøre det i kapittel 13 når vi skal se på Quarto. Nå skal vi videre til et av mine favoritt-temaer i R-universet: kart.\n\n\n\nTidslinje med timelineS\nTidslinje med ggplot2.\nGantt-diagram.\nDendrogram.\nFigur 2: Tidslinje i timelineS uten modifikasjoner.\nFigur 3: Tilpasset tidslinje i timelineS.\nFigur 4: Steg 1 i bygging av tidslinje med ggplot().\nFigur 5: Steg 2 i bygging av tidslinje med ggplot().\nFigur 6: Steg 3 i bygging av tidslinje med ggplot().\nFigur 7: Steg 4 i bygging av tidslinje med ggplot().\nFigur 8: Steg 5 i bygging av tidslinje med ggplot().\nFigur 9: Tidslinje laget med ggplot() — med bilder.\nFigur 10: Tidslinje laget med ggplot() — med bilder og tilpasninger.\nFigur 11: Første steg i bygging av Gantt-diagram med ggplot().\nFigur 12: Andre steg i bygging av Gantt-diagram med ggplot().\nFigur 13: Gantt-diagram laget med ggplot() — med navn i endret rekkefølge.\nFigur 14: Gantt-diagram laget med ggplot() — med navn i snudd rekkefølge.\nFigur 15: Gantt-diagram laget med ggplot() — med modifiserte søyler.\nFigur 16: Gantt-diagram laget med ggplot() — med endret bakgrunn og akse.\nFigur 17: Gantt-diagram laget med ggplot() — med annoteringer.\nFigur 18: Enkelt dendrogram laget med ggraph().\nFigur 19: Dendrogram laget med ggraph() — med tekstbokser.\nFigur 20: Dendrogram laget med ggraph() — med ryddige tekstbokser.\nFigur 21: Dendrogram laget med ggraph() — med fargede bokser.\nFigur 22: Dendrogram laget med ggraph() — snudd 180 grader.\nFigur 23: Dendrogram laget med ggraph() — snudd 90 grader.\nFigur 24: Dendrogram laget med ggraph() — med hardere kurver.\nFigur 25: Dendrogram laget med ggraph() — med vinkler.\nFigur 26: Dendrogram laget med ggraph() — med rette vinkler.\nFigur 35: Nettverksdiagram i ggraph."
  },
  {
    "objectID": "utdrag.html#footnotes",
    "href": "utdrag.html#footnotes",
    "title": "Kapittel 6: Fremstill diagrammer",
    "section": "Fotnoter",
    "text": "Fotnoter\n\n\nVær oppmerksom på at dette skriptet henter bilder fra internett via lenkene i df_slag$bilde. Hvis du ikke har nettilkopling, vil du få feilmelding. Noen ganger kan man også få feilmelding som inneholder uttrykket Timeout was reached. Det betyr at R ikke fikk kontakt med serveren som oppbevarer bildet. Det kan være flere årsaker til det, men problemet er normalt midlertidig, så i slike tilfeller anbefaler jeg å prøve igjen litt senere.↩︎\nDet finnes en rekke R-pakker som lager en spesifikk type Gantt-diagrammer raskt og enkelt; blant annet vistime, ganttrify, candela, DiagrammeR, plotrix og googleVis. Men de fleste er innrettet mot prosjektplanlegging og genererer diagrammer som etter mitt syn ikke er spesielt pene.↩︎\nMerk at mange av parametrene i theme() henviser til x- eller y-aksen og at x nå henviser til aksen med årstall og y til aksen med navn. Det er fordi vi tidligere i skriptet brukte coord_flip(), og theme() forholder seg til grafstrukturen slik den står etter at coord_flip() har vridd om på grafen.↩︎\nI skrivende stund er det dessverre ingen enkel måte å kontrollere fargen på pilhodene på; se https://github.com/mermaid-js/mermaid/issues/1236.↩︎\nDet er også mulig å lage nettverksdiagrammer med igraph og diagrammeR, men ggraph kommuniserer bedre med resten av GG-systemet.↩︎\nhttps://no.wikipedia.org/wiki/Tore_Hund, konsultert 8. mars 2022.↩︎"
  }
]